# -*- coding: utf-8 -*-
"""Contrast+Retinex.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wlOnj8I4C5ivnhgXB52N3yyJbjB0vHqM
"""

import cv2
import os
from google.colab.patches import cv2_imshow
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import files

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="wbs3ef01W1OQTdLhbY9o")
project = rf.workspace("auv-hackathon").project("underwater-object-detection-s8xhb")
dataset = project.version(1).download("coco")

#This is the code to download the dataset

"""# New Section"""

#im_list=[]
#def im_read(n):
 # for i in range(n):
  #  print('Upload File:')
   # upl_file=files.upload()
    #for filename, content in upl_file.items():
     # nparr = np.frombuffer(content, np.uint8)
      #img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
      #if img is not None:
       #     im_list.append(img)
      #else:
       #     print(f"Error reading image: {filename}")

#m=int(input('Enter no. of images'))
#im_read(m)

train_path = '/content/Underwater-object-detection-1/train/'
test_path='/content/Underwater-object-detection-1/test/'
valid_path='/content/Underwater-object-detection-1/valid/'
train_cont = os.listdir('/content/Underwater-object-detection-1/train/')
test_cont=os.listdir('/content/Underwater-object-detection-1/test/')
valid_cont=os.listdir('/content/Underwater-object-detection-1/valid/')
train_str=[]
test_str=[]
valid_str=[]

for item in train_cont:
  if item != "_annotations.coco.json":
    train_str.append(train_path+item)

for item in test_cont:
  if item != "_annotations.coco.json":
    test_str.append(test_path+item)

for item in valid_cont:
  if item != "_annotations.coco.json":
    valid_str.append(valid_path+item)

train_images=[]
for item in train_str:
   img = (cv2.imread(item,cv2.IMREAD_COLOR)).astype(np.uint8)
   img=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
   train_images.append(img)
   plt.imshow(img)
   plt.show()

test_images=[]
for item in test_str:
   img = (cv2.imread(item,cv2.IMREAD_COLOR)).astype(np.uint8)
   img=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
   test_images.append(img)
   plt.imshow(img)
   plt.show()

valid_images=[]
for item in valid_str:
   img = (cv2.imread(item,cv2.IMREAD_COLOR)).astype(np.uint8)
   img=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
   valid_images.append(img)
   plt.imshow(img)
   plt.show()

#Unsharp masking
 #Note that the first image has more contrast but the 2nd is sharper (as demonstrated by lab cvt later)
#blurred = cv2.GaussianBlur(gr_image, (15,15), 0)
#unsharp_gry1 = cv2.addWeighted(gr_image, 3.5, blurred, -1.5, 0)
#unsharp_gry2 = cv2.addWeighted(gr_image, 3.5, blurred, -3.35, 0)

#unsharp_image1 = cv2.cvtColor(unsharp_gry1, cv2.COLOR_GRAY2BGR)
#unsharp_image2=cv2.cvtColor(unsharp_gry2, cv2.COLOR_GRAY2BGR)
#cv2_imshow(unsharp_image1)
#cv2_imshow(unsharp_image2)
#cv2.imwrite('usm.jpg', unsharp_image)
#files.download('usm.jpg')

#BGR TO LAB CVT on the Unsharp Darker Image
#lab_image = cv2.cvtColor(unsharp_image2, cv2.COLOR_BGR2LAB)

# Separate the L (lightness) channel from LAB image
#lt, agr, bby = cv2.split(lab_image)

#l_eq = cv2.equalizeHist(lt)
#Lenh_image = cv2.merge([l_eq, agr, bby])

#cv2_imshow(image)
#cv2_imshow(Lenh_image)
#cv2.imwrite('Lenh_image.jpg',Lenh_image)
#files.download('Lenh_image.jpg')

#WORKING CONTRAST METHOD BEGINS AFTER THIS

#Color Channel Enhancement
def col_enh(img):
   b, g, r = cv2.split(img)
   enh_g = cv2.addWeighted(g, 1.09, np.zeros_like(g), 0, 0)
   enh_b = cv2.addWeighted(b, 0.93, np.zeros_like(b), 0, 0)
   enh_r = cv2.addWeighted(r, 3, np.zeros_like(r), 0, 0)

   enh_image = cv2.merge([enh_b,enh_g,enh_r])
   return(enh_image)

   #Beginning with Retinex
def ret(enh_img):
   im_float = enh_img.astype(np.float32) / 255.0

   log_img = np.log1p(im_float)
   retinex = im_float - cv2.GaussianBlur(log_img, (0, 0), 50)

   # Scale the values back to the range [0, 255]
   retinex = np.clip(retinex * 255.0, 0, 255).astype(np.uint8)
   return(retinex)

print(len(train_images))
print(len(test_images))
print(len(valid_images))

new_train=[]

for img in train_images:
   enh_img=col_enh(img)
   new_train.append(ret(enh_img))

new_test=[]

for img in test_images:
   enh_img=col_enh(img)
   new_test.append(ret(enh_img))

new_valid=[]

for img in valid_images:
   enh_img=col_enh(img)
   new_valid.append(ret(enh_img))

for img in new_test:
    plt.imshow(img)
    plt.show()

##RGHS stuff begins

def global_stretching(img_L,height, width):
    length = height * width
    R_rray = (np.copy(img_L)).flatten()
    R_rray.sort()
    print('R_rray',R_rray)
    I_min = int(R_rray[int(length / 100)])
    I_max = int(R_rray[-int(length / 100)])
    print('I_min',I_min)
    print('I_max',I_max)
    array_Global_histogram_stretching_L = np.zeros((height, width))
    for i in range(0, height):
        for j in range(0, width):
            if img_L[i][j] < I_min:
                p_out = img_L[i][j]
                array_Global_histogram_stretching_L[i][j] = 0
            elif (img_L[i][j] > I_max):
                p_out = img_L[i][j]
                array_Global_histogram_stretching_L[i][j] = 100
            else:
                p_out = int((img_L[i][j] - I_min) * ((100) / (I_max - I_min)))
                array_Global_histogram_stretching_L[i][j] = p_out
    return (array_Global_histogram_stretching_L)

import math
e = math.e

def global_Stretching_ab(a,height, width):
    array_Global_histogram_stretching_L = np.zeros((height, width), 'float64')
    for i in range(0, height):
        for j in range(0, width):
                p_out = a[i][j] * (1.3 ** (1 - math.fabs(a[i][j] / 128)))
                array_Global_histogram_stretching_L[i][j] = p_out
    return (array_Global_histogram_stretching_L)

def stretching(img):
    height = len(img)
    width = len(img[0])
    for k in range(0, 3):
        Max_channel  = np.max(img[:,:,k])
        Min_channel  = np.min(img[:,:,k])
        for i in range(height):
            for j in range(width):
                img[i,j,k] = (img[i,j,k] - Min_channel) * (255 - 0) / (Max_channel - Min_channel)+ 0
    return img

from skimage.color import rgb2hsv,hsv2rgb
from skimage.color import rgb2lab, lab2rgb

def  LABStretching(sceneRadiance):

    sceneRadiance = np.clip(sceneRadiance, 0, 255)
    sceneRadiance = np.uint8(sceneRadiance)
    height = len(sceneRadiance)
    width = len(sceneRadiance[0])
    img_lab = rgb2lab(sceneRadiance)
    L, a, b = cv2.split(img_lab)

    img_L_stretching = global_Stretching_ab(L, height, width)
    img_a_stretching = global_Stretching_ab(a, height, width)
    img_b_stretching = global_Stretching_ab(b, height, width)

    labArray = np.zeros((height, width, 3), 'float64')
    labArray[:, :, 0] = img_L_stretching
    labArray[:, :, 1] = img_a_stretching
    labArray[:, :, 2] = img_b_stretching
    img_rgb = lab2rgb(labArray) * 255

    return img_rgb

    sceneRadiance = np.clip(sceneRadiance, 0, 255)
    sceneRadiance = np.uint8(sceneRadiance)
    height = len(sceneRadiance)
    width = len(sceneRadiance[0])
    img_hsv = rgb2hsv(sceneRadiance)
    img_hsv[:, :, 1] = global_stretching(img_hsv[:, :, 1], height, width)
    img_hsv[:, :, 2] = global_stretching(img_hsv[:, :, 2], height, width)
    img_rgb = hsv2rgb(img_hsv) * 255

    return img_rgb

from scipy import stats

def stretchrange(r_array, height, width):

    length = height * width
    R_rray = r_array.flatten()
    R_rray.sort()
    print('R_rray', R_rray)
    mode = stats.mode(R_rray).mode[0]
    mode_index_before = list(R_rray).index(mode)
    # count = stats.mode(R_rray).count[0]

    SR_min = R_rray[int(mode_index_before * 0.005)]
    SR_max = R_rray[int(-(length - mode_index_before) * 0.005)]

    print('mode',mode)
    print('SR_min',SR_min)
    print('SR_max',SR_max)

    return SR_min, SR_max, mode

pi = math.pi
e = math.e
from scipy import stats



def global_stretching(r_array, height, width, lamda, k):

    length = height * width
    R_rray = []
    for i in range(height):
        for j in range(width):
            R_rray.append(r_array[i][j])
    R_rray.sort()
    I_min = R_rray[int(length / 200)]
    I_max = R_rray[-int(length / 200)]

    array_Global_histogram_stretching = np.zeros((height, width))
    d = 4
    length = height * width
    R_rray = []

    SR_min, SR_max, mode = stretchrange(r_array, height, width)
    DR_min = (1 - 0.655) * mode
    t_n = lamda ** d
    O_max_left = SR_max * t_n * k/ mode
    O_max_right = 255 * t_n * k/ mode
    Dif = O_max_right -O_max_left
    if(Dif >= 1):
        sum = 0
        for i in range(1, int(Dif+1)):
            sum = sum + (1.526+ i) * mode / (t_n * k)
        DR_max = sum/int(Dif)

        for i in range(0, height):
            for j in range(0, width):
                if r_array[i][j] < I_min:

                    p_out = (r_array[i][j] - I_min) * ( DR_min /I_min ) + I_min
                    array_Global_histogram_stretching[i][j] = p_out
                elif (r_array[i][j] > I_max):
                    p_out = (r_array[i][j] - DR_max) * (DR_max / I_max) + I_max
                    array_Global_histogram_stretching[i][j] = p_out
                else:
                    p_out = int((r_array[i][j] - I_min) * ((255 - I_min) / (I_max - I_min))) + I_min
                    array_Global_histogram_stretching[i][j] = p_out
    else:

        if r_array[i][j] < I_min:

            p_out = (r_array[i][j] - np.min(r_array)) * (DR_min / np.min(r_array)) + np.min(r_array)
            array_Global_histogram_stretching[i][j] = p_out
        else:
            p_out = int((r_array[i][j] - I_min) * ((255 - DR_min) / (I_max - I_min))) + DR_min
            array_Global_histogram_stretching[i][j] = p_out

    return (array_Global_histogram_stretching)





def RelativeGHstretching(sceneRadiance, height, width):

    sceneRadiance[:, :, 0] = global_stretching(sceneRadiance[:, :, 0], height, width, 0.97, 1.25)
    sceneRadiance[:, :, 1] = global_stretching(sceneRadiance[:, :, 1], height, width, 0.95, 1.25)
    sceneRadiance[:, :, 2] = global_stretching(sceneRadiance[:, :, 2], height, width, 0.83, 0.85)
    return sceneRadiance

def stretchrange(r_array, height, width):

    length = height * width
    R_rray = r_array.flatten()
    R_rray.sort()
    print('R_rray', R_rray)
    mode = stats.mode(R_rray).mode[0]
    mode_index_before = list(R_rray).index(mode)
    # count = stats.mode(R_rray).count[0]


    DR_min = (1-0.655) * mode





    SR_max = R_rray[int(-(length - mode_index_before) * 0.005)]

    print('mode', mode)
    print('DR_min', DR_min)
    print('SR_max', SR_max)

    return DR_min, SR_max, mode

def cal_equalisation(img,ratio):
    Array = img * ratio
    Array = np.clip(Array, 0, 255)
    return Array

def RGB_equalisation(img):
    img = np.float32(img)
    avg_RGB = []
    for i in range(3):
        avg = np.mean(img[:,:,i])
        avg_RGB.append(avg)
    avg_RGB = 128/np.array(avg_RGB)
    ratio = avg_RGB

    for i in range(0,2):
        img[:,:,i] = cal_equalisation(img[:,:,i],ratio[i])
    return img

x = []  # Make an array of x values
y = []  # Make an array of y values for each x value

for i in range(-128,127):
    x.append(i)

for j in range(-128,127):
    temp  = j *(2**(1 - abs((j/128))))
    y.append(temp)
# print('y',y)

# pl.xlim(-128, 127)# set axis limits
# pl.ylim(-128, 127)
plt.axis([-128, 127,-128, 127])

plt.title('S-model Curve Function ',fontsize=20)# give plot a title
plt.xlabel('Input Value',fontsize=20)# make axis labels
plt.ylabel('Output Value',fontsize=20)




plt.plot(x, y,color='red')  # use pylab to plot x and y
plt.show()  # show the plot on the screen

import natsort
def rghs(img):
        sceneRadiance = img
        # sceneRadiance = RelativeGHstretching(sceneRadiance, height, width)

        sceneRadiance = stretching(sceneRadiance)


        sceneRadiance = LABStretching(sceneRadiance)


       # cv2.imwrite(folder +'/midframe_output/' + prefix + '_RGHS.jpg', sceneRadiance)
        return sceneRadiance

for img in new_train:
   rghs(img)
   plt.imshow(img)

#from PIL import Image, ImageEnhance
#img=Image.fromarray(ret[1])
#enhancer = ImageEnhance.Brightness(img)
#factor=1.5
#img_brightened = np.array(enhancer.enhance(factor))

#cv2_imshow(img_brightened)

cv2.waitKey(0)
cv2.destroyAllWindows()